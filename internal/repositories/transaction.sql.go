// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: transaction.sql

package repositories

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const insertTransaction = `-- name: InsertTransaction :one
INSERT INTO transactions(user_id, status, transaction_type, source_id, source_type ) VALUES($1, $2, $3, $4, $5) RETURNING transaction_id, user_id, status, transaction_type, source_id, source_type, created_at, updated_at
`

type InsertTransactionParams struct {
	UserID          pgtype.UUID     `db:"user_id" json:"user_id"`
	Status          string          `db:"status" json:"status"`
	TransactionType TypeTransaction `db:"transaction_type" json:"transaction_type"`
	SourceID        pgtype.UUID     `db:"source_id" json:"source_id"`
	SourceType      TypeSource      `db:"source_type" json:"source_type"`
}

func (q *Queries) InsertTransaction(ctx context.Context, arg InsertTransactionParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, insertTransaction,
		arg.UserID,
		arg.Status,
		arg.TransactionType,
		arg.SourceID,
		arg.SourceType,
	)
	var i Transaction
	err := row.Scan(
		&i.TransactionID,
		&i.UserID,
		&i.Status,
		&i.TransactionType,
		&i.SourceID,
		&i.SourceType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const selectTransactionByUserId = `-- name: SelectTransactionByUserId :many
SELECT t.transaction_id, t.user_id, t.status, t.transaction_type, t.source_id, t.source_type, t.created_at,
bh.balance_amount_before, bh.balance_amount_after,
t2.top_up_id, t2.top_up_amount,
p.payment_id, p.payment_amount, p.remarks AS payment_remarks,
t3.transfer_id, t3.transfer_amount, t3.remarks AS transfer_remarks
FROM transactions t 
LEFT JOIN balances_histories bh ON bh.transaction_id = t.transaction_id 
LEFT JOIN topups t2 ON t.source_id = t2.top_up_id 
LEFT JOIN payments p ON t.source_id = p.payment_id 
LEFT JOIN transfers t3 ON t.source_id = t3.transfer_id 
WHERE t.user_id = $1
`

type SelectTransactionByUserIdRow struct {
	TransactionID       pgtype.UUID        `db:"transaction_id" json:"transaction_id"`
	UserID              pgtype.UUID        `db:"user_id" json:"user_id"`
	Status              string             `db:"status" json:"status"`
	TransactionType     TypeTransaction    `db:"transaction_type" json:"transaction_type"`
	SourceID            pgtype.UUID        `db:"source_id" json:"source_id"`
	SourceType          TypeSource         `db:"source_type" json:"source_type"`
	CreatedAt           pgtype.Timestamptz `db:"created_at" json:"created_at"`
	BalanceAmountBefore pgtype.Numeric     `db:"balance_amount_before" json:"balance_amount_before"`
	BalanceAmountAfter  pgtype.Numeric     `db:"balance_amount_after" json:"balance_amount_after"`
	TopUpID             pgtype.UUID        `db:"top_up_id" json:"top_up_id"`
	TopUpAmount         pgtype.Numeric     `db:"top_up_amount" json:"top_up_amount"`
	PaymentID           pgtype.UUID        `db:"payment_id" json:"payment_id"`
	PaymentAmount       pgtype.Numeric     `db:"payment_amount" json:"payment_amount"`
	PaymentRemarks      pgtype.Text        `db:"payment_remarks" json:"payment_remarks"`
	TransferID          pgtype.UUID        `db:"transfer_id" json:"transfer_id"`
	TransferAmount      pgtype.Numeric     `db:"transfer_amount" json:"transfer_amount"`
	TransferRemarks     pgtype.Text        `db:"transfer_remarks" json:"transfer_remarks"`
}

func (q *Queries) SelectTransactionByUserId(ctx context.Context, userID pgtype.UUID) ([]SelectTransactionByUserIdRow, error) {
	rows, err := q.db.Query(ctx, selectTransactionByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectTransactionByUserIdRow
	for rows.Next() {
		var i SelectTransactionByUserIdRow
		if err := rows.Scan(
			&i.TransactionID,
			&i.UserID,
			&i.Status,
			&i.TransactionType,
			&i.SourceID,
			&i.SourceType,
			&i.CreatedAt,
			&i.BalanceAmountBefore,
			&i.BalanceAmountAfter,
			&i.TopUpID,
			&i.TopUpAmount,
			&i.PaymentID,
			&i.PaymentAmount,
			&i.PaymentRemarks,
			&i.TransferID,
			&i.TransferAmount,
			&i.TransferRemarks,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
