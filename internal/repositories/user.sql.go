// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: user.sql

package repositories

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const insertUser = `-- name: InsertUser :one
INSERT INTO users(first_name, last_name, phone_number, address, pin) VALUES($1, $2, $3, $4, $5) RETURNING user_id, first_name, last_name, phone_number, address, pin, created_at, updated_at
`

type InsertUserParams struct {
	FirstName   string      `db:"first_name" json:"first_name"`
	LastName    pgtype.Text `db:"last_name" json:"last_name"`
	PhoneNumber string      `db:"phone_number" json:"phone_number"`
	Address     string      `db:"address" json:"address"`
	Pin         string      `db:"pin" json:"pin"`
}

func (q *Queries) InsertUser(ctx context.Context, arg InsertUserParams) (User, error) {
	row := q.db.QueryRow(ctx, insertUser,
		arg.FirstName,
		arg.LastName,
		arg.PhoneNumber,
		arg.Address,
		arg.Pin,
	)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.Address,
		&i.Pin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const selectOneUserById = `-- name: SelectOneUserById :one
SELECT a.user_id, a.first_name, a.last_name, a.phone_number, a.address, b.balance_id, b.balance_amount
FROM users a
JOIN balances b ON b.user_id = a.user_id
WHERE a.user_id = $1
`

type SelectOneUserByIdRow struct {
	UserID        pgtype.UUID    `db:"user_id" json:"user_id"`
	FirstName     string         `db:"first_name" json:"first_name"`
	LastName      pgtype.Text    `db:"last_name" json:"last_name"`
	PhoneNumber   string         `db:"phone_number" json:"phone_number"`
	Address       string         `db:"address" json:"address"`
	BalanceID     pgtype.UUID    `db:"balance_id" json:"balance_id"`
	BalanceAmount pgtype.Numeric `db:"balance_amount" json:"balance_amount"`
}

func (q *Queries) SelectOneUserById(ctx context.Context, userID pgtype.UUID) (SelectOneUserByIdRow, error) {
	row := q.db.QueryRow(ctx, selectOneUserById, userID)
	var i SelectOneUserByIdRow
	err := row.Scan(
		&i.UserID,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.Address,
		&i.BalanceID,
		&i.BalanceAmount,
	)
	return i, err
}

const selectOneUserByPhoneNumber = `-- name: SelectOneUserByPhoneNumber :one
SELECT user_id, first_name, last_name, phone_number, address, pin, created_at FROM users WHERE phone_number = $1
`

type SelectOneUserByPhoneNumberRow struct {
	UserID      pgtype.UUID        `db:"user_id" json:"user_id"`
	FirstName   string             `db:"first_name" json:"first_name"`
	LastName    pgtype.Text        `db:"last_name" json:"last_name"`
	PhoneNumber string             `db:"phone_number" json:"phone_number"`
	Address     string             `db:"address" json:"address"`
	Pin         string             `db:"pin" json:"pin"`
	CreatedAt   pgtype.Timestamptz `db:"created_at" json:"created_at"`
}

func (q *Queries) SelectOneUserByPhoneNumber(ctx context.Context, phoneNumber string) (SelectOneUserByPhoneNumberRow, error) {
	row := q.db.QueryRow(ctx, selectOneUserByPhoneNumber, phoneNumber)
	var i SelectOneUserByPhoneNumberRow
	err := row.Scan(
		&i.UserID,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.Address,
		&i.Pin,
		&i.CreatedAt,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users SET first_name = $1, last_name = $2, address = $3, updated_at = now() WHERE user_id = $4 RETURNING user_id, first_name, last_name, phone_number, address, pin, created_at, updated_at
`

type UpdateUserParams struct {
	FirstName string      `db:"first_name" json:"first_name"`
	LastName  pgtype.Text `db:"last_name" json:"last_name"`
	Address   string      `db:"address" json:"address"`
	UserID    pgtype.UUID `db:"user_id" json:"user_id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.FirstName,
		arg.LastName,
		arg.Address,
		arg.UserID,
	)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.Address,
		&i.Pin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
